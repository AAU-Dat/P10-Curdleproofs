%! Author = ander
%! Date = 18-10-2024
\section{Attacks on Ethereum}\label{sec:attacks-on-ethereum}
\subsection{Reorg}\label{subsec:reorg}

\subsection{DoS}\label{subsec:dos}
We've found three different kinds of DoS attacks that either were or are possible to perform on Ethereum.

One of the attacks is called \textit{under-priced opcodes}~\cite{10.1145/3391195,9815256}.
This attack works because Ethereum has a gas mechanism to reduce abuse of computing resources.
Though when a contract has a lot of underpriced opcodes, they will consume many resources.
Execution of contracts requires a lot of resources.

To mitigate this,
Ethereum has raised the gas cost of opcodes
to preserve the number of transactions-per-second~\cite{Opcode-mitigation}~\footnote{
\href{https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md}{EIPs/EIPS/eip-150.md at master ethereum/EIPs GitHub}}.

Another attack,
which is closely related to the former, is \textit{empty account in the state trie}~\cite{10.1145/3391195,9815256}.
This attack was possible
because the existence of empty accounts increases the transaction processing time and synchronization.
An empty account is an account with zero balance and no code.
The attack required the proposer to select only the transactions of the adversary,
which could be insured by offering a higher gas price.

The mitigation is a combination of the one
explained for \textit{under-priced opcodes} as well as a mitigation
for clearing empty accounts~\cite{Opcode-mitigation,empty-account-mitigation,empty-account-eip-mitigation}~\footnote{
\href{https://github.com/ethereum/EIPs/blob/master/EIPS/eip-161.md}{EIPs/EIPS/eip-161.md at master ethereum/EIPs GitHub}}.

The last example of a DoS attack is called \textit{Proposer DoS}~\cite{EthereumSSLE2024,EthereumAttackDefense2024}.
The background to making this attack possible is
that the consensus mechanism uses a publicly known function for choosing the upcoming block proposers.
The adversary is therefore able to compute this in slight advance of the blockchain, s.t.\ each proposer is now known.
After this, the adversary can map the proposer's IP addresses and overload their connection.
A successful attack would leave a proposer unable to propose their block in time.

To prevent this kind of attack,
Ethereum plans
to use something they call~\gls{ssle} which ensures
that only the selected validator knows that they have been selected~\cite{EthereumSSLE2024,EthereumResearchSSLE2024}.

Specifically, a proposal has been made to use an election protocol called Whisk, which is a type of~\gls{ssle}~\cite{Whisk2024}\footnote{\href{https://github.com/ethresearch/Shuffle_SSLE/tree/master/rust_code/src}{Shuffle\_SSLE/rust\_code/src at master ethresearch/Shuffle\_SSLE GitHub}}\footnote{\href{https://github.com/ethereum/consensus-specs/pull/2800}{[WIP] Introduce consensus code for Whisk (SSLE) by asn-d6 Pull Request \#2800 ethereum/consensus-specs GitHub}}\footnote{\href{https://github.com/dapplion/lighthouse/tree/whisk}{GitHub - dapplion/lighthouse at whisk}}.
It works by each validator submitting a commitment to a secret shared by all validators.
The commitments are shuffled s.t.\ no-one can map commitments to the validators,
but each validator knows what commitment belongs to them.
This shuffle-phase goes on for a day, 256 epochs, before using the shuffled proposer list the following day.
Commitments are chosen at random, and the selected proposer will detect its commitment to know when to propose a block.

The shuffling phase requires validators to occasionally shuffle a subset of candidate proposers.
Using a subset is a measure to reduce computation for the validators, as 256 epochs correspond to 8912 proposers.
The shuffle requires a validator to construct a~\gls{zkp} to confirm that the shuffle was performed correctly.

\subsection{Balancing Attack}\label{subsec:balancing-attack}
For this type, we found two attacks.

The first attack we call \textit{LMD-specific balancing attack}~\cite{10.1145/3560829.3563560}.
This attack exploits the~\gls{lmd} \textit{proposer
boosting} by sending out two competing blocks
but giving half the validators one block before the other and the opposite for the other half.
This would create a fork in the blockchain.

Although no mitigation is mentioned,
it requires $W_p/b+1$ adversarial slots~\footnote{where $W_p$ is the proposer boost weight (fx 100 validators/slot: $W_p=0.7\cdot100=70$)
    and $b$ is the fraction of adversaries in the committee in each slot}.


Another balancing attack has the adversary
exploiting adversarial network delay
and strategic voting by a vanishing fraction of adversarial validators
to stall the protocol indefinitely~\cite{10.1007/978-3-031-18283-9_28}~\footnote{
\href{https://github.com/tse-group/gasper-gossip-attack}{GitHub - tse-group/gasper-gossip-attack}}.

Though this attack does depend on networking assumptions that are highly contrived in practice; those being the attacker having fine-grained control over latencies of individual validators.

\subsection{Finality Attack (Bouncing Attack)}\label{subsec:finality-attack-(bouncing-attack)}

\subsection{Avalanche Attack}\label{subsec:avalanche-attack}

\subsection{Bribery}\label{subsec:bribery}

\subsection{Staircase Attack}\label{subsec:staircase-attack}