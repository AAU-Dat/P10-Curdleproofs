
\section{Background}\label{sec:background}
In this section, we will go through some of the concepts that will be used in the rest of the paper as well as some surrounding context for the attack.

\subsection{Ethereum and Proof of Stake}\label{subsec:ethereum-and-proof-of-stake}
Ethereum is a blockchain platform that allows developers to create decentralized applications using smart contracts.
Previously operating with a~\gls{pow} consensus algorithm, Ethereum transitioned to a~\gls{pos} consensus algorithm in 2022.
This transition was done to reduce the energy consumption of the network and to increase the scalability of the network.
The transition was done in a series of upgrades called the Ethereum 2.0 upgrade.
~\gls{pos} is a consensus algorithm that is used to secure blockchain net by helping to create new blocks and confirm transactions.
It works by creating validators based on the amount of cryptocurrency they have staked.
Then it selects some of these validators as proposers to be the ones to create new blocks, which then are confirmed by the rest of the validators.
The proposers then get rewarded for creating a valid block and the validators get rewarded for confirming the block.
Block proposing happens within epochs of 32 blocks per epochs and for each epoch a group of validators is selected and from them a proposer is chosen.
the way the proposer is chosen is through a random proses that is weighted by the amount of cryptocurrency the validator has staked, and by using the publicly available \gls{randao} algorithm to simulate the random selection.
The blocks also have a time limit of 12 seconds to be created and confirmed else the block will be discarded and the proposer is penalized.
If a fork happens the validators have to choose which fork to follow.
This is done by using the \gls{lmd-ghost} algorithm which chooses the fork with the greatest weight of attestations in its history~\cite{EthereumProof-of-stakePoS}.

\subsection{subnets}\label{subsec:subnets}
The Ethereum network is split up into smaller networks called subnets.
These subnets are used to help with the scalability of the network.
The nodes in the network are split into total of 64 subnets and an additional subnet for attestation aggregates with each node being part of at least two subnets.
Within a subnet, nodes choose a subset of peers in the same subnet to share its messages with.
Choosing which notes are a part of this subset is done based on the peers performances.
Nodes send all messages they hear about within a subnet to these best-performing peers.
The peers a node can reach within the same subnet is called its fanout~\cite{heimbach2024deanonymizingethereumvalidatorsp2p}.



%\subsection{Zero-Knowledge Proofs}\label{subsec:zero-knowledge-proofs}
%A~\gls{zkp} is a cryptographic method that allows one party to prove to another party that something is true without revealing any information.
%
%Two of the subcategories of \gls{zkp}s are \gls{zk-snark} and \gls{zk-stark}.
%~\gls{zk-snark} is the more common of the two.
%It uses elliptic curve cryptography to create proofs based on the assumption that it is hard to find the discrete logarithm form the publicly known base point.
%~\gls{zk-snark} has a start-up ritual which requires a trusted setup by all parties involved that the original proving key is destroyed as to not be able to create fake proofs.
%A criticism of \gls{zk-snark} is that it is not quantum resistant because of the reliance on elliptic curve cryptography.
%
%~\gls{zk-stark} on the other hand, is a newer and more complex~\gls{zkp}.
%Despite not having non-interactive in its name,~\gls{zk-stark} is also non-interactive.
%Different form~\gls{zk-snark},~\gls{zk-stark} uses hashing functions to create proofs instead of elliptic curves.
%This method is post-quantum secure and does not require a trusted setup.
%It does, however, come with a higher computational cost and is not as widely used and documented as~\gls{zk-snark}.

\subsection{Validators}\label{subsec:validator}
Our attack is primarily focused on the validators of Ethereum.
A validator is an entity running on a validator client,
which, among other things, consists of a balance and a key-pair for identifying it~\cite{Staking}.
One client can run several validators.

The validators have a central job in keeping the blockchain running.
At each slot, a validator in Ethereum is at random chosen to be responsible for processing transactions,
including them in a block,
and then adding this block to the blockchain.
How we determine who is going to be a block proposer will be explained in~\autoref{subsec:randao}.
Along with this, the validator is also responsible for attesting blocks proposed by other validators,
ensuring the liveness of the chain.

To be able to have a single validator, one must deposit 32 ETH,
which is ~\$99,776\footnote{As of 2024-11-18 seen on \href{https://beaconcha.in/}{beaconcha.in}}.
Having this much money at stake should be enough to ensure that a validator acts honestly.
Doing so will also earn the validator a reward, but contrary to that,
acting dishonest will get you ETH burned or slashed.
The rewards and punishments will be described in the following.
\subsubsection{Validator rewards}\label{subsubsec:valrewards}
Validators are rewarded for several different actions~\cite{PoSRewAndPen}.
Each of these actions is rewarded with different weights,
but they all depend on the total amount of staked ETH by validators and the validator's own staked amount limited to 32 ETH\@.
A base reward, which is used on the reward weights, is calculated for a single validator as follows:
\begin{equation}
    BR = EB\cdot(\frac{BRF}{BRPE\cdot \sqrt{\sum{AB}}})
    \label{eq:basereward}
\end{equation}, where \texttt{BR} is \textit{base reward},
\texttt{EB} is \textit{effective balance}, \texttt{BRF} is \textit{base reward factor} set to 64,
\texttt{BRPE} is \textit{base rewards per epoch} set to 4,
and \texttt{AB} is \textit{active balance}, which is the total staked ETH by validators.

The reward for a validator is then calculated as follows:
\begin{equation}
    \frac{\sum{weights}}{64}\cdot BR
    \label{eq:valrewards}
\end{equation}
The summed over weights are the following:
\begin{enumerate}
    \item Timely source vote: 14
    \item Timely target vote: 26
    \item Timely head vote: 14
    \item Sync reward: 2
    \item Proposer weight: 8
\end{enumerate}
Though not the highest weight, the most profitable reward is actually the proposer weight reward.
The validator is rewarded with this, whenever they are chosen and correctly propose a block to the blockchain.
But instead of being rewarded this only once,
the proposer is getting the reward as many times as there are attestations.
\begin{equation}
    BR\cdot\frac{8}{64}\cdot \#attestations\label
    {eq:propreward}
\end{equation}
Because the maximum number of attestations is 128,
then in a typical and optimal situation,
the proposer will get $BR\cdot\frac{8}{64}\cdot128$ in reward
when proposing a block~\cite{PoSRewAndPen,consensus-spec-phase-0}.
Thus, with the average amount of staked ETH for a validator being over 32 ETH, which means almost equal chance of being proposer, and with Ethereum having over 1 million validators, validators do not want to miss being the proposer\footnote{As of 2024-11-18 seen on \href{https://beaconcha.in/}{beaconcha.in}}.

\subsubsection{Validator punishments}\label{subsubsec:valpunish}
A validator can also be punished for doing things that do not contribute to the chain performing as it should.
Ethereum has two kinds of penalties, burning and slashing, where a validator loses some of their staked ETH\@.
Should a validator lose their ETH and end up below 16 staked ETH, they will be removed~\cite{consensus-spec-phase-0}.


Burning happens per epoch when a validator is offline.
If ETH gets burned, it is gone forever.
To calculate how much ETH is retained after burning per offline epoch, ~$n$, the following formula is used:
\begin{equation}
    \left(1-\frac{1}{IPQ}\right)^\frac{n^2}{2}
    \label{eq:burn}
\end{equation},
with \texttt{IPQ} being the \textit{inactivity penalty quotient} set to $2^{26}$~\cite{consensus-spec-phase-0}.


This means that a validator being offline in a single epoch still retains $0,99999999255\%$ of their staked ETH\@.
A validator would therefore need
to be offline for a lot of epochs before eventually being removed for having under 16 staked ETH\@.


Slashing happens when only when a validator acts maliciously against the blockchain,
and cannot be invoked only by being offline.
Slashing happens from at least one of three causes~\cite{PoSRewAndPen}:
\begin{enumerate}
    \item Proposing two different blocks at the same slot
    \item Attesting a block that surrounds another
    \item Double voting - Attesting to candidates for the same block
\end{enumerate}
If this is detected, ~$\frac{1}{32}$ of the validator's staked ETH is immediately burned,
and a 36-day removal period of the validator begins, where the staked ETH is gradually burned.
Halfway through this, on day 18, an additional penalty is applied.
The magnitude of this penalty scales with the total staked ETH of the slashed validators in the 36-day period before the slashing event.
At worst, a validator can end up having all their ETH burned, if enough other validators are also slashed.

\subsection{RANDAO}\label{subsec:randao}
As mentioned in~\autoref{subsec:validator}, the validators are chosen to propose a block by a random-number-generator called RANDAO\footnote{\href{https://github.com/randao/randao}{RANDAO - GitHub}}.
The random selection is decided by the RANDAO algorithm, which is used every slot.
Each chosen proposer will get the RANDAO value computed at the previous slot and \texttt{XOR} it with the hash of their private key and epoch number.


This creates what is called the RANDAO reveal.
It can be verified with the proposer's public key.
This, of course, happens at all 32 slots of an epoch, making up the randomness of the reveal.
At the end of each epoch, the latest reveal constitutes to the seed, which is used to determine who the next proposers are going to be.


Being chosen as a block proposer comes with some duties, such as creating the block.
This means that they need to know in advance if they are going to be the proposer of a block.

The proposer selection among the validators is done two epochs in advance~\cite{random-selection}.
More specifically, the selection for epoch $n+2$ happens at the end of epoch $n$~\cite{upgrading-ethereum-randomness}.
This means that a validator knows at least one epoch, at most two epochs, in advance if they are proposing a block.


\subsection{ENR}\label{subsec:enr}
A~\gls{enr} is a record that contains information about a node in the network~\cite{EIP-778:Ethereum-Node-Records}.
Ethereum uses~\glspl{enr} as a way
to package the information that is being sent from node to node during the discovery protocol,
where nodes discover each other.
The package contains information like the node's IP address, port, and public key.
Because of the nature of the discovery protocol, if you where to also be a node in Ethereum,
you would be able to see the~\gls{enr} of all the nodes that you have discovered.
And since the~\gls{enr} contains the IP address and the public key of the node,
you would be able
to see the corresponding IP addresses and public keys of all the nodes that have been discovered by the node.


\subsection{other paper}\label{subsec:other-papers} \todo{new titel}
\todo{make acronym for the paper}
In the paper "deanonymizing ethereum users" the authors show that it is possible to deanonymize validators on the Ethereum network by observing attestations and subscribing to subnets~\cite{heimbach2024deanonymizingethereumvalidatorsp2p}.
This paper is relevant to our work as it shows that it is possible to get information about the validators on the network.
This paper is also the main inspiration for our attack.
The paper takes advantage of the attestations and subnet setup to get information about the validators.
For their setup they use a custom version of a Prysm node called RAINBOW that subscribe to all subnets, and they use to log and color the information gathered.
This information consists of all attestations, their origin, and their origin subnet, all advertised static subscriptions of our peers and precise connection data for all nodes we interact with.
To help speed up the discovery of the peers they also used a crawler to more quickly find the peers using the discovery protocol and the peer tables.
In their execution of their experiment they set up four nodes spread out across four different geographical locations.
They then let the nodes run for three days and managed to deanonymize 235,719 validators and reached out to 11,219 peers.
These peers were also divided into 4 categories based on their heuristic.
Those being deanonymized where they located validators on the machine with the heuristic conditions being upheld, No validators where they did not receive a single non-backbone attestation received from the peer, and so they assume that there are no validators on the peer, 64 subnets where they never receive a non-backbone attestation from the peer which makes it impossible to deanonymize the validators and the rest where they got at least one non-backbone attestation but where not able to locate any validators on the peer.




\subsection{Proposer DoS Attack}\label{subsec:proposer-dos-attack}
In this subsection, we will be describing the attack that we will be using as a basis for our experiment in ~\autoref{sec:experimental-protocol}.
The attack is a~\gls{dos} attack that aims at hitting the proposers selected for creating blocks in the chain.
Ethereum themselves have mentioned it as a potential attack, and with the current implementation of the consensus algorithm, it seems that this attack is possible to perform~\cite{EthereumSSLE2024,EthereumAttackDefense2024}.

It has been our interest to research the feasibility of this attack and the ones mentioned in~\autoref{sec:attacks-on-ethereum}.
This has proven to be a difficult task, given that most of our researched attacks happen in the consensus- or execution layer.
Therefore, as a result of the blockchain algorithm, we are not able to clarify the feasibility of the attacks that we have found.
For this reason, we have chosen the \textit{Proposer~\gls{dos} attack} as it seems exciting, has not been mitigated yet, and a potential solutions seems to include a~\gls{zkp}.
%\todo{Does it make sense to mention \# skipped blocks pr day even though we are unsure if any of these are attacks}

The attack possible is because the consensus mechanism uses a publicly known function for choosing the upcoming block proposers.
The adversary is therefore able to compute this in slight advance of the blockchain, s.t.\ each proposer is now known.
After this, the adversary can map the proposer's IP addresses and overload their connection.
A successful attack would leave a proposer unable to propose their block in time.\todo{Should possibly be explained in more detail}