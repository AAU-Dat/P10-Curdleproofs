\section{approach}\label{sec:approach}


\subsection{Shuffle security}\label{sec:approach-shuffle-security}
The shuffle method proposed by Larsen et al.~\cite{cryptoeprint:2022/560} that was used in curdleproofs is based on the idea of shuffling a list of proposers over a set of slots.
The shuffle itself however is not too complex.
A formal definition of the shuffle is given in~\autoref{fig:shuffle}.

\begin{figure}[ht]\label{fig:shuffle}

    \begin{framed}
        \[
            \Pi(c_1, \ldots, c_n)
        \]
        \rule{\linewidth}{0.4pt}

        \noindent
        \textbf{for} $t \in [T]$ \textbf{:}
        \begin{itemize}
            \item[$S_t$] picks random $\{i_1, \ldots, i_k\} \subset [n]$
            \item[$S_t$] computes $(\tilde{c}_{i_1}, \ldots, \tilde{c}_{i_k}) \leftarrow \text{Shuffle}(c_{i_1}, \ldots, c_{i_k})$
            \item[$S_t$] publishes $(\tilde{c}_{i_1}, \ldots, \tilde{c}_{i_k})$
        \end{itemize}
    \end{framed}
    \caption{Distributed shuffling protocol.}
\end{figure}

Here the set $(c_1, \ldots, c_n)$ is a set of ciphertexts that are shuffled over $T$ slots.
In each slot $t$, a subset of the ciphertexts ${i_1, \ldots, i_k}$ is chosen randomly and shuffled and added back to the list of ciphertexts.
it is then encrypts the ciphertexts again and publishes them.
This process is repeated for $T$ slots and the shuffle is complete.
during the $T$ shuffles some of the shufflers may be adversarial.
This means that whenever the shuffling process is taking place a part of the shuffles may be adversarial which can be seen as not being shuffled.
therefore the amount of honest shuffles that happen durring the shuffle process is $T_H = T - \alpha$.
where $\alpha$ is the amount of adversarial shufflers.

The Shuffle is secure if none of these two events occur.
The first event is a short backtracking, where an adversary can find the original ciphertexts from the shuffled ciphertexts.
since the subsets of ciphertexts are chosen randomly in each shuffle, if is enough adversarial shufflers in a row to end the process, then a shot backtrack is possible.

The second event that can occur is that since every shuffle distributes the possibility of a certain ciphertext to be in a certain slot.
Then if a shuffle contains a lot of ciphertext with a larger than average chance of containing a certain ciphertext, then that would imply that there is a higher chance of that ciphertext being in that slot.

It is theoretically possible to find a shuffle size and a number of shuffles given an amount of adversarial shufflers to guarantee that the shuffle is secure.
For any $0 < \delta < 1/3$, if $T \geq 20 n / k \ln(n/\delta) + \beta $ and $ k \geq 256 \ln^2(n/\delta)(1 - \alpha/n)^{-2}$.
If $T$ and $k$ are chosen such that the above two conditions are met, then the protocol is an $(\epsilon , \delta)$-secure $(T,n,k)$-shuffle in the presence of a $(\alpha, \beta)$-adversary where $\epsilon = 2/(n-\alpha)$.

This formula is the lowest theoretically proven bound for $T$ and $k$.
It is however possible to find lower secure values for $T$ and $k$ but this has to be done experimentally.



\subsection{Springproofs}\label{sec:approach-springproofs}
In Chapter 6 of Curdleproofs~\cite{Curdleproofs}, they explain the efficiency of the protocol, including also the size of the proof.
They specifically mention that the proof has size $18+10 \log(\ell+4)\mathbb{G}$, $7\mathbb{F}$.
As the proof size is dependent on the size of the shuffle, $\ell$, an interest in the possibility of reducing this parameter arises.
The current proposal of curdleproofs only works on shuffles, where the size is a power of 2.
The reason is that the underlying proofs, such as the inner product argument, needs to fold recursively down to 1, by halving the size in every round.

The Springproofs protocol~\cite{zhang2024springproofs}, as mentioned in~\autoref{sec:background-springproofs}, can be used very effectively in this scenario.
It provides support for IPAs to use vectors of arbitrary length.
Using the findings of Springproofs means Curdleproofs could decrease its proof size, as $\ell$ is no longer locked on a power of 2.

One of the most notable findings in Springproofs is the usage of their so-called scheme function.
This function is used to ensure that the inner product argument eventually will fold down to a vector of size 1.
The core concept of the function is to split the vector before each recursive round of the protocol.
Then, the fold is only done on one of the two sets.

Springproofs present different scheme functions and prove some of them to be optimal.
One of these functions is an optimized version of their \textit{pre-compression method}, which splits the vectors in the following way:

\begin{figure}[ht]\label{fig:schemefunc}
\begin{framed}
    \begin{lstlisting}[language=Python,mathescape=true,label={lst:schemefunc}]
    input: $n$, where $n>0$

    $\{n\}\gets n$
    $N\gets 2^{\lceil\log n\rceil-1}$
    $i_h \gets \lfloor (2N-n)/2\rfloor+1$
    $i_t=\lfloor n/2\rfloor$
    if $n\neq N$:
        $\{T\}\gets(i_h:i_t)\cup(N+1:n)$
    else if $n=N$:
        $\{T\}\gets(1:n)$
    $\{S\}\gets\{n\}-\{T\}$
    \end{lstlisting}
\end{framed}
\caption{Scheme function \textbf{\textit{f}} used in CAAUrdleproofs}
\end{figure}

\begin{figure}[ht]\label{fig:ipa-prover}
\begin{framed}
\begin{lstlisting}[language=Python,mathescape=true,label={lst:ipa-prover}]
$\textbf{Step 1:}$
$\textbf{r}_C,\textbf{r}_D\overset{\$}{\leftarrow}\mathbb{F}^n$
 where $(\textbf{r}_C\times \textbf{d} + \textbf{r}_D\times \textbf{c})=0\text{ and }\textbf{r}_C\times \textbf{r}_D=0$
$B_C\gets \textbf{r}_C\times \textbf{G}$
$B_D\gets \textbf{r}_D\times \textbf{G}'$
$\alpha,\beta\gets$Hash$(C,D,z,B_C,B_C)$
$\textbf{c}\gets \textbf{r}_C+\alpha \textbf{c}$
$\textbf{d}\gets \textbf{r}_D+\alpha \textbf{d}$
$H\gets\beta H$
$\textbf{Step 2:}$
$m\gets n$
while $1\leq j\leq\lceil \log m\rceil:$
    $T,S\gets \textbf{\textit{f(}}n\textbf{\textit{)}}$
    $n\gets \frac{|T|}{2}$
    $\textbf{c}=\textbf{c}_T$, $\textbf{cS}=\textbf{c}_S$
    $\textbf{d}=\textbf{d}_T$, $\textbf{dS}=\textbf{d}_S$
    $\textbf{G}=\textbf{G}_T$, $\textbf{GS}=\textbf{G}_S$
    $\textbf{G}'=\textbf{G}'_T$, $\textbf{GS}'=\textbf{G}'_T$
    $L_{C,j}\gets\textbf{c}_{[:n]}\times\textbf{G}_{[n:]}+(\textbf{c}_{[:n]}\times\textbf{d}_{[n:]})H$
    $L_{D,j}\gets\textbf{d}_{[n:]}\times\textbf{G}'_{[:n]}$
    $R_{C,j}\gets\textbf{c}_{[n:]}\times\textbf{G}_{[:n]}+(\textbf{c}_{[n:]}\times\textbf{d}_{[:n]})H$
    $R_{D,j}\gets\textbf{d}_{[:n]}\times\textbf{G}'_{[n:]}$
    $\pi_j\gets(L_{C,j},L_{D,j},R_{C,j},R_{D,j})$
    $\gamma_j\gets Hash(\pi_j)$
    $\textbf{c}\gets\textbf{cS}\|\textbf{c}_{[:n]}+\gamma_j^{-1}\textbf{c}_{[n:]}$
    $\textbf{d}\gets\textbf{dS}\|\textbf{d}_{[:n]}+\gamma_j\textbf{d}_{[n:]}$
    $\textbf{G}\gets\textbf{GS}\|\textbf{G}_{[:n]}+\gamma_j\textbf{G}_{[n:]}$
    $\textbf{G}'\gets\textbf{GS}'\|\textbf{G}'_{[:n]}+\gamma_j^{-1}\textbf{G}'_{[n:]}$
    $n\gets len(c)$
$\textbf{Step 3:}$
$c\gets c_1$
$d\gets d_1$

return $(B_C,B_D,\mathbf{\pi},c,d)$
\end{lstlisting}
\end{framed}
\caption{Prover computation for CAAU-IPA in CAAUrdleproofs}
\end{figure}

\begin{figure}[ht]\label{fig:ipa-verifier}
\begin{framed}
\begin{lstlisting}[language=Python,mathescape=true,label={lst:ipa-verifier}]
$\textbf{Step 1:}$
$(\textbf{G},\textbf{G}',H)\gets$parse$(crs_{dl_{inner}})$
$(C,D,z)\gets$parse$(\phi_{dl_{inner}})$
$(B_C,B_D,\mathbf{\pi},c,d)\gets$parse$(\pi_{dl_{inner}})$
$\alpha,\beta\gets$Hash$(C,D,z,B_C,B_D)$
$H\gets \beta H$
$C\gets B_C+\alpha C+(\alpha^2z)H$
$D\gets B_D+\alpha D$

$\textbf{Step 2:}$
$m\gets \lceil\log n\rceil$
for $1\leq j\leq m$
    $T,S\gets \textbf{\textit{f(}}n\textbf{\textit{)}}$
    $n\gets \frac{|T|}{2}$
    $\textbf{G}=\textbf{G}_T$, $\textbf{GS}=\textbf{G}_S$
    $\textbf{G}'=\textbf{G}'_T$, $\textbf{GS}'=\textbf{G}'_T$
    $(L_{C,j},L_{D,j},R_{C,j},R_{D,j})\gets$parse$(\pi_j)$
    $\gamma_j\gets$Hash$(\pi_j)$
    $C\gets\gamma_j L_{C,j}+C+\gamma_j^{-1}R_{C,j}$
    $D\gets\gamma_j L_{D,j}+D+\gamma_j^{-1}R_{D,j}$
    $\textbf{G}\gets\textbf{GS}\|\textbf{G}_{[:n]}+\gamma_j\textbf{G}_{[n:]}$
    $\textbf{G}'\gets\textbf{GS}'\|\textbf{G}'_{[:n]}+\gamma_j^{-1}\textbf{G}'_{[n:]}$
    $n\gets\text{len}(\textbf{G})$

$\textbf{Step 3:}$
Check $C=c\times G_1+cdH$
Check $D=d\times G'_1$
$\text{return 1 if both checks pass, else return 0}$
\end{lstlisting}
\end{framed}
\caption{Verifier computation for CAAU-IPA in CAAUrdleproofs}
\end{figure}



\subsection{implementation}\label{subsec:approach-implementation}


