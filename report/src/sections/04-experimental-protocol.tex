

\section{Experimental protocol}\label{sec:experimental-protocol}

\subsection{Validators}\label{subsec:validator}
Our attack is primarily focussed on the so-called validators of Ethereum.

The inner core making the Ethereum PoS work is the continually generated blocks.
Though, these blocks still require being processed by someone.
This is what a validator does~\cite{Staking}.
The validator is responsible for processing transaction, including them in a block,
and then adding this block to the blockchain.
How we determine, who is going to be a block proposer will be explained in~\autoref{subsec:randao}.

To be able to have a single validator, one must deposit 32 ETH, which is ~\$99,776.
Having this much money at stake should be enough to ensure that a validator acts honestly.
Doing so will also earn the validator a reward, but contrary to that,
acting dishonest will get you ETH burned or slashed.
The rewards and punishments will be described in the following.
\subsubsection{Validator rewards}\label{subsubsec:valrewards}
Validators are rewarded for several different actions~\cite{PoSRewAndPen}.
Each of these actions is rewarded with different weights,
but they all depend on the total amount of staked ETH by validators and the validator's own staked amount limited to 32 ETH\@.
A base reward, which is used on the reward weights, is calculated for a single validator as follows:
\begin{equation}
    BR = EB\cdot(\frac{BRF}{BRPE\cdot \sqrt{\sum{AB}}})
    \label{eq:basereward}
\end{equation}, where \texttt{BR} is \textit{base reward}, \texttt{EB} is \textit{effective balance}, \texttt{BRF} is \textit{base reward factor} set to 64, \texttt{BRPE} is \textit{base rewards per epoch} set to 4, and \texttt{AB} is \textit{active balance}, which is the total staked ETH by validators.

The reward for a validator is then calculated as follows:
\begin{equation}
    \frac{\sum{weights}}{64}\cdot BR
    \label{eq:valrewards}
\end{equation}
The summed over weights are the following:
\begin{enumerate}
    \item Timely source vote: 14
    \item Timely target vote: 26
    \item Timely head vote: 14
    \item Sync reward: 2
    \item Proposer weight: 8
\end{enumerate}
Though not the highest weight, the most profitable reward is actually the proposer weight reward.
The validator is rewarded with this, whenever they are chosen and correctly propose a block to the blockchain.
But instead of being rewarded this only once, the proposer is getting the reward as many times as there are attestations.
\begin{equation}
    BR\cdot\frac{8}{64}\cdot \#attestations\label
    {eq:propreward}
\end{equation}
Because the maximum number of attestations is 128, then in a typical and optimal situation, the proposer will get $BR\cdot\frac{8}{64}\cdot128$ in reward when proposing a block~\cite{PoSRewAndPen,consensus-spec-phase-0}.
Thus, with the average amount of staked ETH for a validator being over 32 ETH, which means almost equal chance of being proposer, and with Ethereum having over 1 million validators, validators do not want to miss being the proposer\footnote{As of 2024-11-18 seen on \href{https://beaconcha.in/}{beaconcha.in}}.

\subsubsection{Validator punishments}\label{subsubsec:valpunish}
A validator can also be punished for doing things that do not contribute to the chain performing as it should.
Ethereum has two kinds of penalties, burning and slashing, where a validator loses some of their staked ETH\@.
Should a validator lose their ETH and end up below 16 staked ETH, they will be removed~\cite{consensus-spec-phase-0}.


Burning happens per epoch when a validator is offline.
If ETH gets burned, it is gone forever.
To calculate how much ETH is retained after burning per offline epoch, ~$n$, the following formula is used:
\begin{equation}
\left(1-\frac{1}{IPQ}\right)^\frac{n^2}{2}
\label{eq:burn}
\end{equation}, with \texttt{IPQ} being the \textit{inactivity penalty quotient} set to $2^{26}$~\cite{consensus-spec-phase-0}.


This means that a validator being offline in a single epoch still retains $0,99999999255\%$ of their staked ETH\@.
A validator would therefore need to be offline for a lot of epochs before eventually being removed for having under 16 staked ETH\@.


Slashing happens when only when a validator acts maliciously against the blockchain, and cannot be invoked only by being offline.
Slashing happens from at least one of three causes~\cite{PoSRewAndPen}:
\begin{enumerate}
    \item Proposing two different blocks at the same slot
    \item Attesting a block that surrounds another
    \item Double voting - Attesting to candidates for the same block
\end{enumerate}
If this is detected, ~$\frac{1}{32}$ of the validator's staked ETH is immediately burned, and a 36-day removal period of the validator begins, where the staked ETH is gradually burned.
Halfway through this, on day 18, an additional penalty is applied.
The magnitude of this penalty scales with the total staked ETH of the slashed validators in the 36-day period before the slashing event.
At worst, a validator can end up having all their ETH burned, if enough other validators are also slashed.

\subsection{RANDAO}\label{subsec:randao}

\subsection{ENR}\label{subsec:enr}
A~\gls{enr} is a record that contains information about a node in the network~\cite{EIP-778:Ethereum-Node-Records}.
Ethereum uses~\glspl{enr} as a way
to package the information that is being sent from node to node during the discovery protocol,
where nodes discover each other.
The package contains information like the node's IP address, port, and public key.
Because of the nature of the discovery protocol, if you where to also be a node in Ethereum,
you would be able to see the~\gls{enr} of all the nodes that you have discovered.
And since the~\gls{enr} contains the IP address and the public key of the node,
you would be able
to see the corresponding IP addresses and public keys of all the nodes that have been discovered by the node.


\todo{
    How do we simulate the attack?
    What variables do we want to control?
    Severity of attack - Slow down node or make node disappear?
}

\textit{THOUGHT (DEPRECATED): I think it would make sense to test both a slow node, and a frozen/dead node.
Linux kernel Traffic Control (tc) and Netem (part of tc) seems like the best choice for simulating network issues.}
