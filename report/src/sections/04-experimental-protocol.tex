

\section{Experimental Protocol}\label{sec:experimental-protocol}
In this section, we will cover the motivation and the workings of the attack that will be performed.
We also describe the setup of the experiment that will be conducted and the experiment itself.

\subsection{Motivation}\label{subsec:proposer-dos-attack}
\subsubsection{Proposer DoS Attack}
In this section, we will be describing the attack that acts as motivation for doing our experiment.
The attack is a~\gls{dos} attack aiming to halt the proposers selected for creating blocks in the chain.
Ethereum themselves have mentioned it as a potential attack, and with the current implementation of the consensus algorithm, this attack is likely to perform~\cite{EthereumSSLE2024,EthereumAttackDefense2024}.

We are interested in researching the feasibility of this attack and the ones mentioned in~\autoref{sec:attacks-on-ethereum}.
Researching feasibility has proven difficult, given that most of our researches involve attacks in the consensus or execution layer.
This makes verifying that an attack has occurred challenging.
For this reason, we have chosen the \textit{Proposer~\gls{dos} attack} as it seems exciting and has not been mitigated yet.

The attack is possible because the consensus mechanism uses a publicly known function to choose the upcoming block proposers.
Therefore, the adversary can compute this in advance of the upcoming slots in the blockchain so each upcoming proposer is known.
After this, the adversary can map the proposer's IP addresses and overload their connection.
A successful attack would prevent a proposer from proposing their block in time.

\subsubsection{Adversarial Incentives for the Attack}

Several reasons can explain why an adversary would be interested in performing this kind of attack.
This applies to adversaries running a node with validators and adversaries running a node without validators in the network.


The first reason, not requiring any validators, could be exploiting the inactivity penalization mentioned in~\autoref{subsubsec:valpunish}.
The adversary could make validators lose money for being inactive.
For the adversaries themselves, they do not receive any monetary rewards from this attack.
One could be interested in getting people kicked from being a validator for having below 16 staked ether.
However, it can quickly be derived from~\autoref{eq:burn} that the~\gls{dos} attack must be ongoing for at least 9,645 epochs ($\sim$43 days) before a validator goes from 32 ether to under 16 ether.


Having more focus on targeting upcoming proposers, the adversary can limit the rewards that the proposers are promised.
Proposers get the greatest reward after proposing a block, see~\autoref{subsubsec:valrewards}, so the adversary could limit the rewards given to proposers.
In the worst case, this could decrease the total amount of ether, as it is dynamically changing with the chain.


Both reasons only require an Ethereum node, but the adversary does not gain any reward from the attack.
Monetary gain could be a possibility if the adversary is in control of a validator.
The reason for this is found in the~\gls{mev}~\cite{mev}.

~\gls{mev} refers to the maximum value one can extract from a block production opportunity.
It is a reward that the proposer can get besides rewards from routine work on the blockchain, as mentioned in~\autoref{subsubsec:valrewards}.
The idea of~\gls{mev} is that \textit{searchers} search the network for profitable transaction opportunities.
These are, for instance, opportunities where people are willing to pay a high transaction fee to the proposer for inclusion in the block.
These transactions are then added to the pool of transactions to be added to the chain.
More implementations of these searchers are being made, i.e., Flashbots and MEV-Boost.
It is estimated that ~90\% of Ethereum validators use this kind of software~\cite{cryptoeprint:2023/760}.

So, let us assume a scenario in which an adversary has a validator set to propose the block at slot $n$.
It could then be beneficial for the adversary to perform a~\gls{dos} attack on the proposers of the previous slots.
Beginning from slot $n-1$ and down, the more consecutive proposers successfully attacked, the more potential gain the adversary has.
The increase in potential gain is because the high-paying transactions, to be included in the previous slots, can now be included in the adversary's slot.
Therefore, the adversary potentially gains a greater reward from including those transactions with higher fees now available because of the attack.



\subsection{Attack Description}\label{subsec:attack-description}
The overall goal of the attack is to be able to withhold validators from performing their eventual proposer duties, as mentioned in~\cite{EthereumAttackDefense2024}.
The idea is that the adversary would interrupt validators using a~\gls{dos} attack.
The attack is divided into two parts.
First, we need to know validator IP addresses, which are found by de-anonymizing the validators.
This part of the attack will be explored below.
The second part of the attack is to determine when a specific validator will produce a block.
By utilizing the de-anonymized validators, the adversary should be able to perform a~\gls{dos} attack on the upcoming block proposers.

\subsubsection{Getting Validator IPs}
When a node is a part of the Ethereum network,
it receives messages in the form of attestations from other nodes in the network.
These attestations are split into two different categories: backbone and non-backbone attestations.
A backbone attestation is typically a routine message sent between peers in the same subnet.
Here, the nodes forward messages to each other that they did not construct themselves.
To explain non-backbone attestations, we refer directly to the observation in~\cite{heimbach2024deanonymizingethereumvalidatorsp2p}.
\\\\
\textit{\textbf{Observation 1.} An ideal peer will only send us an attestation in a subnet they are not a backbone of
if they are the signer of the attestation, and we are in their fanout for the corresponding subnet of the attestation.}
\\\\

Optimally, all non-backbone attestations that our node receives should be constructed by the node that sent it to us.
Therefore, in a perfect scenario, we link the validator associated with the non-backbone attestation to the peer that sent the message.

However, many things are uncertain when sending messages over the internet.
For instance, we may never receive a message because of network instability.
As stated by~\cite{heimbach2024deanonymizingethereumvalidatorsp2p}, nodes can also run non-default configurations, i.e.,\ subscribing to more than two subnets, increasing the number of messages one will receive from that node.
We may also wrongly label messages as backbone or non-backbone because of a lack of or delayed information regarding a node's backbone subnets.

Because of this, the authors of the~\gls{de-anon paper} developed a heuristic to tell if a given validator could be linked with a given node~\cite{heimbach2024deanonymizingethereumvalidatorsp2p}.
The heuristic and its application are described in~\autoref{subsec:inspirational-papers}.

Assuming that we will be able to de-anonymize validators, we can take advantage of the fact that an Ethereum node always needs to include its~\gls{enr} when sending messages over the network.
As explained in~\autoref{subsec:enr}, the node IP is always included in the~\gls{enr}, which this attack takes advantage of.

\subsubsection{Finding Proposer Duties for a Proposer DoS attack}
Applying the aforementioned heuristic to the logged data will enable us to get a list of de-anonymized validators in which the IP addresses of the nodes are included because of the~\glspl{enr}.
Now that we have linked validators with IP addresses, we need to determine which validators will propose upcoming blocks in the blockchain.

Having de-anonymized validators means that the~\gls{randao} proposer selection is vulnerable, but not limited, to a DoS attack.
More specifically, performing the Proposer DoS attack as mentioned in~\autoref{subsec:proposer-dos-attack} is possible.

In~\autoref{subsec:randao}, we found that the proposers for an entire epoch are chosen at least one epoch in advance.
Gathering the proposer duties can be easily obtained, as Ethereum provides an API endpoint for the blockchain, providing information on the chain~\footnote{The API calls are found at \href{https://ethereum.github.io/beacon-APIs/\#/Validator/getProposerDuties}{ethereum.github.io/beacon-APIs}}.
The adversary would only need an Ethereum node to use this API; a validator is not required.
Not needing a validator is especially beneficial, as one can perform the attack without staking any money into Ethereum.

The output of a call to the API returns a list of slots.
Each component in the list is the chosen validator's public key, ID, and the slot in which they are chosen to propose a block.

Therefore, a list of the de-anonymized validators could be iterated, with the adversary's goal being to match the proposers for the upcoming epoch.
The de-anonymization includes the IP addresses of the validators as well as their ID and public key.
So, having matched the upcoming proposers with de-anonymized validators, an adversary now ideally knows the IP addresses of several upcoming proposers.

This information allows the adversary to~\gls{dos} the specific IP address, which could leave the proposer inactive at their designated slot.

\subsection{De-anonymization Attack Implementation}\label{subsec:attack-implementation}
Being able to de-anonymize validators revolves around modifying a fork of the Prysm consensus client.

To implement the attack, one must find where the different functionalities are written in the code.
Modifying just two classes in the code is enough to make the attack possible: one for handling peers and another for handling attestations.

It is also important to remember that the core functionality of Prysm is never changed.
So, no changes have been made to variables already used in the Prysm client.




\subsubsection{Peers}\label{subsubsec:peers}
The attestation logs include all data also included in the peer logs.
Therefore, the peers will be described first.
All changes are done to the \texttt{beacon-chain} files in Prysm.

A pointer to a \texttt{Service} object is typically maintained in the different classes of the Prysm code.
This object implements an interface for handling functionality coupled with the given class.
The class that handles~\gls{p2p} connections also has such an object, with several specific functions for handling a peer.

Because of said object, information about all earlier or connected peers is available.
Set to run every minute, the modified code requests all peers and iterates through them,
logging information.

For a peer, by accessing the \texttt{service} class in the \texttt{p2p} files, we are able to log:
\begin{itemize}
     \item Node ID
     \item IP address
     \item Subscribed subnets
     \item Connection state
     \item Connection direction (which node discovered the other node)
     \item ENR
\end{itemize}


Also, in each iteration, the collected information is sent to an \texttt{SQL} database to process the data later.

\subsubsection{Attestations}\label{subsubsec:attestations}
Everything logged for the peers is also logged for the attestations, as there is always an underlying node sending each attestation.

The class handling the attestations called \texttt{validate\_beacon\_attestation}, also has a \texttt{Service} interface implementation.
This implementation primarily includes functions specific to the attestations and not peers.
Therefore, each \texttt{Service} object has a pointer to a configuration of the running chain.
Referencing this pointer allows the class to access functions like those in the~\gls{p2p} class.

We log information about an attestation whenever we receive one.

With the proposer~\gls{dos} attack in mind, we are interested in receiving the public key and ID of the validator, the creator of the attestation.
Also, we want the IP address of the peer that sent the attestation to the node.

Getting the public key uses an existing function called \texttt{extractPublicKey}, which uses the attestation's data to get the public key and ID of the validator.
Getting the IP address is also straightforward, as the peer \texttt{Service} object includes a function called \texttt{address}, returning the address of the peer who sent the attestation.

In addition to this, we also log the following information available from processing the attestation:
\begin{itemize}
     \item Subnet which the attestation was sent to
     \item Slot associated to the attestation
     \item Source
     \item Target
\end{itemize}

After collecting all the information available for an attestation, the data is logged to an \texttt{SQL} database.

\subsection{Experimental Setup}\label{subsec:setup}
For the experiment, we modified the implementation of the Prysm consensus client~\cite{prysm}.
Prysm is one of the most used clients for connecting with the consensus layer~\cite{client-diversity}.
The Prysm node is modified to subscribe to all 64 network subnets, enabling it to receive as many attestations as possible.
Additionally, aiming for experimental consistency with the~\gls{de-anon paper}, we allow our node to connect to up to 1,000 peers.

The only change is that we log the data as explained in~\autoref{subsec:attack-implementation}.
Apart from that, our node performs tasks like any other Ethereum node would.


We aim to de-anonymize validators on as many peers as we come in contact with.
However, this requires a lot of computational resources when the node is subscribed to all subnets.
Our instance of the modified Prysm node was running in cooperation with a Go-Ethereum execution client.
The client was then run on a virtual machine hosted on Strato CLAAUDIA through Aalborg University.
The virtual machine had 16 virtual CPUs and 64 GB of RAM available.
The physical location of the virtual machine is in Denmark.

While still aiming for consistency concerning the~\gls{de-anon paper}, we collect data over three days (December 13th, 13:04 UTC to December 16th, 13:12 UTC).
Around 300 GB of data was collected into a PostgreSQL database and processed in PostgreSQL\@.


The client was connected to the Holesky testnet to start receiving attestations and connecting with other peers.
Since the experiment is of an adversarial nature, the client was connected to a testnet instead of the mainnet.

While the client was running, it was able to log information on the received attestations and the peers it discovered.
We logged the same peer and attestation data as described in~\autoref{subsec:attack-implementation}
The data that was logged was then stored in a database for further analysis.
After this, the peers were sorted into the same four categories mentioned in~\autoref{subsec:inspirational-papers}, initially developed in the~\gls{de-anon paper}~\cite{heimbach2024deanonymizingethereumvalidatorsp2p}.